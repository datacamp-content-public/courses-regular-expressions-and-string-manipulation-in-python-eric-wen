---
title: Insert title here
key: d15d73f08145d2bf07a7ea82e5afa437

---
## Lesson 2.4: Searching and Compilation Flags

```yaml
type: "TitleSlide"
key: "adb3efc71c"
```

`@lower_third`

name: Eric Wen
title: Candidate for Instructor


`@script`



---
## Topics

```yaml
type: "FullSlide"
key: "4c206cbe49"
```

`@part1`
- Review of the list introduced in Lesson 1 as an example

- Review of previous Lesson, 2.3, that  introduced the wildcard . and quantifiers + ? * and {}

- Introducing searching in contrast to matching

- Compilation flags


`@script`
In this brief section we will begin with a quick review of the


---
## Review of the List Introduced in Lesson 1 as an Example

```yaml
type: "TwoColumns"
key: "4da1725d7c"
```

`@part1`
Introduced list `li_names` in Lesson 1:

     `li_names = ['Adele'
                , 'Alan'
                , 'Ana-Maria'
                , 'Aolani'
                , 'Arlene']`


`@part2`



`@script`
To provide a consistent context for studying regular expressions, the list `li_names` was introduced in Lesson 1 and has been used consistently throughout Lessons 1 and 2.  As you can see, it consists of five names, and regular expressions have been and will be applied to this list of strings.


---
## Review of the List Introduced in Lesson 1 as an Example

```yaml
type: "TwoColumns"
key: "da17c139d6"
disable_transition: true
```

`@part1`
Introduced list `li_names` in Lesson 1:

     `li_names = ['Adele'
                , 'Alan'
                , 'Ana-Maria'
                , 'Aolani'
                , 'Arlene']`


`@part2`
Used a `for` loop to traverse it:


     `for sname in li_names:
          print(f'{sname}')`

_output:_

     `Adele
      Alan
      Ana-Maria
      Aolani
      Arlene`


`@script`



---
## Review of Previous Lesson: Introduced wildcard . and Quantifiers

```yaml
type: "FullSlide"
key: "bc6e28c66a"
```

`@part1`
In Lesson 2.3 we built the following compiled regular expression and applied `re.match()` to the elements or our list, `li_names`:

     `import re
      regexobj = re.compile(r'.*an')
      for sname in li_names:
           romatch = regexobj.match(sname)
           print(f'{sname:11}{bool(romatch)} \t{romatch}')`

_output:_

     `Adele       False     None
      Alan        True      <re.Match  object; span=(0, 4), match='Alan'>
      Ana-Maria   False     None
      Aolani      True      <re.Match  object; span=(0, 5), match='Aolan'>
      Arlene      False     None`


`@script`



---
## Searching vs. Matching

```yaml
type: "FullSlide"
key: "0ebb0213f5"
```

`@part1`
Recall our continuing example using the list of names:

     `li_names = ['Adele', 'Alan', 'Ana-Maria', 'Aolani', 'Arlene']`

In order to match `Alan` and `Aolani`, we observe that both contain the letters `an` while none of the other three names does.

Thus, we have compiled the regular expression:

     `regexobj = re.compile(r'.*an')`


`@script`
Recall our continuing example using the list of names:


---
## `regexobj = re.compile(r'.*an')`

```yaml
type: "FullCodeSlide"
key: "418b893c06"
```

`@part1`
We apply this compiled regular expression to the list of names as follows:

    `for sname in li_names:
         romatch = regexobj.match(sname)
         print(f'{sname:7} \t{bool(romatch)}\t{romatch}')`


`@script`



---
## Output

```yaml
type: "FullSlide"
key: "e5a077ef2e"
```

`@part1`
Here is the output:

`Adele           False   None`
`Alan            True    <re.Match object; span=(0, 4), match='Alan'>
`Ana-Maria       False   None`
`Aolani          True    <re.Match object; span=(0, 5), match='Aolan'>`
`Arlene          False   None`
`


`@script`



---
## Final Slide

```yaml
type: "FinalSlide"
key: "9b8a15d40e"
```

`@script`
script section

